



CREATE PROCEDURE [AM].[USP_ALERTS_MANAGER]
	@RTN INT = Null OUTPUT		--<=OPTIONAL (DO NOT SEND)
AS

	SET NOCOUNT ON
	DECLARE @ART_CTRL_MASTER_ID INTEGER
	DECLARE @BATCH_DATE AS DATE
	DECLARE @ALERT_PRIORITY AS VARCHAR(100)
	DECLARE @ALERT_CONTEXT AS VARCHAR(200)
	DECLARE @RETRY_THRESHOLD AS INTEGER
	DECLARE @RETRY_COUNT AS INTEGER
	DECLARE @ART_NME AS VARCHAR(100)
	DECLARE @EXEC_TYPE AS VARCHAR(50)
	DECLARE @LAST_LOAD_ID AS INTEGER
	DECLARE @LAST_EXEC_ID AS INTEGER 
	DECLARE @LAST_BATCH_DTE AS DATE
	DECLARE @ALERT_MSG AS VARCHAR(400)
	DECLARE @ALERT_TASK AS VARCHAR(200)
	DECLARE @ALERT_CNT AS INTEGER
	DECLARE @UPD_MSG AS BIT = 0

	BEGIN TRY
		BEGIN
			-- REMOVE TEMP TABLE IF EXISTS
			IF OBJECT_ID(N'tempdb..#ALERT_QUEUE', N'U') IS NOT NULL 
			BEGIN  
				DROP TABLE #ALERT_QUEUE; 
			END
			
			
			-- SET QUERY ACM TO FIND ALL CURRENT ARTIFACTS THAT NEED AN ALERT
			-- CREATE A TEMP TABLE TO LOOP THROUGH
			SELECT acm.ART_CTRL_MASTER_ID, acm.ART_NME, acm.LAST_LOAD_ID
			,ISNULL(acm.LAST_BATCH_DTE,GETDATE()) as 'LAST_BATCH_DTE'
			,[AM].[UDF_ALERT_CONTEXT](ACM.ART_BATCH_RETRY_COUNTER, ACM.ART_BATCH_RETRY_THRESHOLD, ACM.SCHEDULE_MODE_VALUE_ID) as 'ALERT_MSG'
			,ACM.ART_BATCH_RETRY_COUNTER, ACM.ART_BATCH_RETRY_THRESHOLD, ACM.LAST_EXEC_ID
			INTO #ALERT_QUEUE
			FROM AM.ARTIFACT_CTRL_MASTER ACM 
			JOIN SSISDB.CATALOG.executions (NOLOCK) CE
				ON ACM.LAST_EXEC_ID = CE.execution_id
			LEFT JOIN AM.ALERTS A
				ON ACM.LAST_EXEC_ID  = A.EXECUTION_ID
			WHERE CE.STATUS IN (3, 4, 6) 
				and A.MSG_UPDATED_DTE IS NULL
				and A.EXECUTION_ID IS NULL
			
			-- SET THE COUNTER FOR NUMBER OF RECORDS THAT NEED ALERTS CREATED
			SET @ALERT_CNT = (SELECT COUNT(1) 'CNT' FROM #ALERT_QUEUE) 
			

			-- SET QUERY ACM TO FIND ALL CURRENT ARTIFACTS THAT NEED AN ALERT
			WHILE @ALERT_CNT > 0
				BEGIN
					-- IF THE UPD_MSG = 1 IT MEANS AN ALERT WAS CREATED 0 MEANS NO ALERTS CREATED
					SET @UPD_MSG = 1

					-- PULL THE FIRST RECORD FROM THE TEMP TABLE THAT NEEDS AN ALERT CREATED
					SELECT TOP 1  
						 @ART_CTRL_MASTER_ID = ART_CTRL_MASTER_ID
						,@ART_NME = ART_NME
						,@LAST_LOAD_ID = LAST_LOAD_ID
						,@LAST_BATCH_DTE = LAST_BATCH_DTE
						,@ALERT_MSG = ALERT_MSG
						,@RETRY_COUNT = ART_BATCH_RETRY_COUNTER
						,@RETRY_THRESHOLD = ART_BATCH_RETRY_THRESHOLD
						,@LAST_EXEC_ID = LAST_EXEC_ID
						,@ALERT_PRIORITY = LEFT(ALERT_MSG, Charindex('|',ALERT_MSG)-1) 
						,@ALERT_CONTEXT = RIGHT(ALERT_MSG, LEN(ALERT_MSG)  - Charindex('|',ALERT_MSG)) 
					FROM #ALERT_QUEUE
					
					-- CREATE THE ALERT
					INSERT INTO AM.ALERTS(LOAD_ID, EXECUTION_ID, BATCH_DATE,ART_TYPE_DESC, ALERT_PRIORITY,ALERT_CONTEXT
					,ART_CTRL_MASTER_ID , ARTIFACT_NAME, RETRY_COUNT, RETRY_THRESHOLD, MSG_SOURCE, CREATED_DTE)
							
					VALUES(@LAST_LOAD_ID, @LAST_EXEC_ID, @LAST_BATCH_DTE, 'Package', @ALERT_PRIORITY, @ALERT_CONTEXT 
					,@ART_CTRL_MASTER_ID, @ART_NME,@RETRY_COUNT, @RETRY_THRESHOLD, 'INFORMATION WILL POSTED SOON', GETDATE())

					-- DELETE THE CURRENT RECORD FROM THE TEMP QUEUE
					DELETE FROM #ALERT_QUEUE WHERE LAST_EXEC_ID = @LAST_EXEC_ID

					-- RESET THE COUNT OF RECORDS IN THE TEMP QUEUE
					SET @ALERT_CNT = (SELECT COUNT(1) 'CNT' FROM #ALERT_QUEUE) 

				END
				
				-- IF THERE WAS AN ALERT CRATED CALL THE SSIS DB PACKAGE THAT GATHERS THE MESSAGES FOR THE ALERTS
				-- NOTE MESSAGES TAKE TIME TO WRITE TO THE SSIS DB, AND THIS PROCEDURE IS CALLED IN LINE FROM AN EXECUTING SSIS PACKAGE
				-- FROM USP_PKG_ON_ERROR, THIS SSIS PACKAGE IS CALLED ASYNC WITH A WAIT SO IT WILL ALWAYS PICK UP THE CURRENTLY EXECUTED PACKAGE.
				
				IF @UPD_MSG = 1 
					BEGIN
						-- CALLS THE SSIS PACKAGE TO UPDATE THE ERROR MESSAGES						--
						DECLARE @EXEC_ID INT
					    --************************************************************************************************************************************************************
						--**** EXECUTE PACKAGE ***************************************************************************************************************************************
						--************************************************************************************************************************************************************
						EXEC @EXEC_ID = [AM].[USP_QM_EXECUTE_PACKAGE] 1164
						--************************************************************************************************************************************************************
					END 
			
			SET @RTN = 1
			RETURN @RTN --Positive Return
		END

	END TRY
	BEGIN CATCH
		 DECLARE @ProcName AS NVARCHAR(128) = ISNULL(ERROR_PROCEDURE(), 'UNKNOWN');
		 DECLARE @ER_PLAT as VARCHAR(128) = 'MSSQL DB ENGINE'
		 DECLARE @ER_NBR AS INTEGER = ISNULL(ERROR_NUMBER(),0)
		 DECLARE @ER_LINE AS INTEGER = ISNULL(ERROR_LINE(),0)
		 DECLARE @ER_SEV AS INTEGER = ISNULL(ERROR_SEVERITY(),0)
		 DECLARE @ER_ST AS INTEGER = ISNULL(ERROR_STATE(),0)
		 DECLARE @ER_MSG AS NVARCHAR(4000) = ISNULL(ERROR_MESSAGE(), 'A MESSAGE WAS NOT PROVIDED');
		 DECLARE @ER_USR AS VARCHAR(255) = ISNULL(CURRENT_USER, 'UNKONWN')

		 EXECUTE @RTN =  AM.USP_ERR_LOG @ProcName, @ER_PLAT, @ER_NBR, @ER_LINE, @ER_SEV, @ER_ST,@ER_MSG, @ER_USR	
		 RETURN @RTN --Returns LOG_ID From [AM].[PROCEDURE_ERROR_LOG]  as a negitive integer
	END CATCH;








